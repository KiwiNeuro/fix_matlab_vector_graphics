#target Illustrator// script.name = fixMatlabPDFOutput.jsx// script.description = deletes all PageItems being used as clipping masks, unites all paths with the same fill color.// script.parent = Dene Farrell // 12/14/2016// script.elegant = true?// Check Java Script Version$.writeln('running fixMatlabPDFOutput');//Doing Everything Herefunction main(){    clipScan();    fill_colorlist = findPaths();    joinPaths();    saveAndQuit();}main();//Defining functions below here//loops through all pageItems, removing those that are clipping masksfunction clipScan () {    var clippingCount = 0;    if ( app.documents.length == 0 ) {        return;    }    var docRef = app.activeDocument;    try {        for (i = docRef.pageItems.length - 1; i >= 0; i--) {            if (docRef.pageItems[i].clipping == true) {                docRef.pageItems[i].remove();                clippingCount++;            }        }        //alert ("All "+clippingCount+" Clipping Masks Removed")    }    catch(err) {        $.writeln('clipping removal code did not work.');    }};// get keysfunction getKeys(obj) {    var keys = [];    for (var key in obj) {        keys.push(key);    }    return keys;}// get colorfunction getColor(obj) {    var fillColorType = obj.typename;    switch (fillColorType) {        case "NoColor":            //$.writeln('no color!');            colorOut = [0.5, 0.5, 0.5];            return colorOut;            break;        case "RGBColor":            //$.writeln('found RGB');            //pathRef.fillColor.red.toString(16)            colorOut = [obj.red, obj.green, obj.blue];            return colorOut;            break;        case "GrayColor":            //$.writeln('found Gray');            colorOut = [obj.gray, obj.gray, obj.gray];            return colorOut;            break;        default:            //$.writeln('defaulted');            //$.writeln("The fill color on object number " + i + " is of type " + fillColorType);            colorOut = [0.5, 0.5, 0.5];            return colorOut;            break;    }}// Get type of variable functionfunction toType(obj) {    return ({}).toString.call(obj).match(/\s([a-zA-Z]+)/)[1].toLowerCase()}// Find fill Color of All Path Itemsfunction findPaths () {    if (app.documents.length > 0 && app.activeDocument.pathItems.length > 0) {        doc = app.activeDocument;        var fill_colorlist = [];        //var stroke_colorlist = [];        for (var i = 0; ((i < doc.pathItems.length)); i++) {            pathRef = doc.pathItems[i];            if ((pathRef.filled == true) && (pathRef.fillColor != undefined && pathRef.fillColor !== null) && (pathRef.fillColor.typename != "NoColor")) {                var fillColorType = pathRef.fillColor.typename;                //$.writeln("fillColorType is " + fillColorType);                tmp_color = getColor(pathRef.fillColor);                var keys = getKeys(pathRef.fillColor);                //$.writeln(keys);                //$.writeln(tmp_color + '--- tmp_color');                fill_colorlist.push(tmp_color);            }        }    }    return fill_colorlist}// Unique functionfunction onlyUnique(value, index, self) {     return self.indexOf(value) === index;}// faster unique (without filter)function uniq_fast(a) {    var seen = {};    var out = [];    var len = a.length;    var j = 0;    for(var i = 0; i < len; i++) {        var item = a[i];        if(seen[item] !== 1) {            seen[item] = 1;            out[j++] = item;        }    }    return out;}// Join all paths with the same fill colorfunction joinPaths () {    //Check that doc is open and has some paths    if (app.documents.length > 0 && app.activeDocument.pathItems.length > 0) {        doc = app.activeDocument;        //Check that some fill colors were found        if (fill_colorlist.length > 0) {            var numcols_str = fill_colorlist.length + " (nonunique) colors found";            var typevar_str = toType(fill_colorlist) + " ---- data type for fill_colorlist";            var first_col_str = fill_colorlist[0] + " ---- first part of fill_colorlist";            $.writeln(numcols_str);            //$.writeln(typevar_str);            //$.writeln(first_col_str);            //alert(numcols_str);            //alert(typevar_str);            //alert(first_col_str);            var unique_clist = uniq_fast(fill_colorlist);            var unique_col_str = unique_clist + " ---- unique_clist";            var first_unique_col_str = unique_clist[0] + " ---- first part of unique_clist";            //$.writeln(unique_col_str);            //$.writeln(first_unique_col_str);            //alert(unique_col_str);            //alert(first_unique_col_str);            //Run through all colors            for (var i = 0; i < unique_clist.length; i++) {                tmp_color = unique_clist[i];                grouped_inds = [];                // find all paths that match current color                for (var j = 0; ((j < doc.pathItems.length)); j++) {                    pathRef = doc.pathItems[j];                    if ((pathRef.filled == true) && (pathRef.fillColor != undefined && pathRef.fillColor !== null) && (pathRef.fillColor.typename != "NoColor")) {                        tmp_path_color = getColor(doc.pathItems[j].fillColor);                        // ignore if it's White!!                        if (!((tmp_color[0]==0)&&(tmp_color[1]==0)&&(tmp_color[2]==0))) {                            if ((tmp_color[0] == tmp_path_color[0]) && (tmp_color[1] == tmp_path_color[1]) && (tmp_color[2] == tmp_path_color[2])) {                                grouped_inds.push(j);                                //$.writeln('match found!');                            }                        }                    }                }                $.writeln('path inds: ' + grouped_inds);                // add all paths to color group                //var tmpGroup = app.activeDocument.groupItems.add();                //var tmpPath = doc.pathItems[grouped_inds];                //tmpGroup.pathItems.add(tmpPath);                for (var k = 0; (k < grouped_inds.length); k++) {                    ind = grouped_inds[k];                    doc.pathItems[ind].selected = true;                }                app.executeMenuCommand('group');                app.executeMenuCommand('Live Pathfinder Add');                app.executeMenuCommand('expandStyle');                app.executeMenuCommand('deselectall');            }        }    }}function saveAndQuit () {    // save as (new file)    var originalInteractionLevel = userInteractionLevel;    app.UserInteractionLevel = UserInteractionLevel.DONTDISPLAYALERTS;    var dest = "~/SRC/extras/modifying-pdfs/test.pdf";    if (false) {        saveFileToPDF(dest);    }    function saveFileToPDF(dest) {        var doc = app.activeDocument;        if (app.documents.length > 0) {            var saveName = new File(dest);            saveOpts = new PDFSaveOptions();            saveOpts.compatibility = PDFCompatibility.ACROBAT5;            saveOpts.generateThumbnails = true;            saveOpts.preserveEditability = true;            alert(saveName);            doc.saveAs(saveName, saveOpts);        }    }    // save and close    if (app.documents.length > 0) {        var docRef = app.activeDocument;        docRef.close(SaveOptions.SAVECHANGES);    }    userInteractionLevel = originalInteractionLevel;    //app.quit();}